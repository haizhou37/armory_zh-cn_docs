# 坦克游戏

<iframe width="560" height="315" src="https://www.youtube.com/embed/5b97eR5_fQI?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

我们来做个小游戏吧！它将包括2名玩家操纵坦克并且互相战斗。我们建造了一个有障碍物和两辆坦克模型的小操场。每个物体都有一个刚体。一些障碍是动画的时间线，以使游戏更有活力。照明设置基于[场景教程](/getting_started/playground.md).

![](/getting_started/img/tanks/1.jpg)

红色坦克充当玩家1。我们允许键盘和游戏手柄控制，但为了简单起见对实际使用的键位采用硬编码。在**Player1Controls**节点树中, 键盘或游戏手柄上的左键被设置发送名为 **'turn_left'** 的事件。稍后，我们使用这个事件来旋转玩家控制的坦克。
![](/getting_started/img/tanks/2.jpg)

对所有的键位做同样的事 - 左，右，向前和向后。

![](/getting_started/img/tanks/3.jpg)

蓝色坦克充当玩家2。我们定义相同的控制，但是将键位映射到WSAD和第二个连接的游戏手柄。
在**TankTree**中,我们监听事件并执行实际控制坦克的动作。之所以这个节点树是分开的，是因为我们将它附加到两个坦克中，从而防止重复的节点树。

**On Event**节点被设置成监听 **'turn_left'** 事件。对于玩家1，此事件是在按左键时触发的。对于玩家2，它发生在按下A键时。 **On Event**节点连接到**旋转物体**节点，而**向量Z** 值设置为控制旋转速度的一个小的正值。现在播放游戏，按左键旋转坦克！
![](/getting_started/img/tanks/4.jpg)

我们对 **'turn_right'** 事件做同样的事，然而**向量Z**值设置为负值，使其以相反的方式旋转。

关于对 **'forward'** 事件的处理。为了弄清楚坦克应该朝哪个方向移动，**变换向量**节点的类型设置为**Look**。然后用**向量数学**缩放这个向量来减慢坦克向前移动的速度。 向量结果传递到**移动物体**节点。

![](/getting_started/img/tanks/5.jpg)

和以前一样，我们对 **'backward'** 事件做同样的事，移动反向向量。

现在坦克是完全可控的，我们让他们发射子弹。为了保持场景清晰，子弹物体被放置在第二场景层，**禁用渲染**。这确保了对象将被导出，但它本身是不可见的。

![](/getting_started/img/tanks/6.jpg)

如果选择红色坦克，则将空对象添加到子对象 - 该物体的位置定义了从哪里发射子弹。一个新的逻辑树被添加到这个空对象中。M键或游戏手柄叉/A键发射 **'fire'** 事件。我们对蓝色坦克也是这样。

![](/getting_started/img/tanks/7.jpg)

我们将另一个逻辑树处理响应附加到 **'fire'** 事件。我们生成一个新的物体 - 在层2的子弹模型的位置设置为逻辑树所有者 - 在这种情况下，子弹生成点 - 定义为放置为坦克子类的空物体。

![](/getting_started/img/tanks/8.jpg)

现在播放场景，我们发现从大炮出来的子弹下降到地面。我们需要一些火药！

![](/getting_started/img/tanks/a.jpg)

**施加冲击力**节点能解决它。类似于向前移动坦克，我们获取前向向量，并将其放大。

![](/getting_started/img/tanks/9.jpg)

尽管Armory能筛除屏幕外的物体，但将使用的资源减少到最低限度也是重要的。 我们移除在生命周期的2秒后的子弹。为了做到这一点，放置一个**数组（物体）** 节点，并用**添加数组**节点将所有发射的子弹存储在此数组中。我们通过**休眠**节点等待2秒并调用**移除物体**节点。**数组切换**节点将第一个元素从子弹数组输入到**移除对象**节点，并将此元素从数组本身中移除。

![](/getting_started/img/tanks/10.jpg)

就这样-你可以自由地做进一步的实验了！获得本教程的全部混合内容：

- https://github.com/armory3d/armory_tutorials/tree/master/tanks
